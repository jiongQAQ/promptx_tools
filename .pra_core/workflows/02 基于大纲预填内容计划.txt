【流程 02｜基于大纲预填 content.json（证据驱动、模块化｜复用 1.1/1.2 产物并自动生成总体ER图）】

目标
1 读取 ./paper/outline.json 与 ./templates/content.template.json
2 对大纲中每个章节创建对应的内容项（写入 ./paper/content.json），并根据章节类型自动决定：
   - single / list 模式
   - 是否需要正文 / 图 / 表
   - （若为 list）生成顺序子项 items[]，仅渲染为编号段落，不新增标题层级
3 同步替换大纲中的技术与功能占位符（如 {{jishu1}}/{{jishu2}}/{{jishu3}}、{{functionname}}/{{funname}}），写回 outline.json，并在 content.json 使用替换后的标题
4 数据库设计章节直接复用步骤 1.1 的三线表 JSON 与步骤 1.2 的同名 SVG；若总体 ER 图不存在则自动生成（PlantUML + luban-uml）

输入
- ./paper/outline.json
- ./templates/content.template.json
- ./source/ 与 ./CLAUDE.md（若存在）
- （来自 1.1）./paper/exports/tables/Tab-*.json
- （来自 1.2）./paper/exports/tables/Tab-*.svg

通用规则
1 严格基于源码/文档/1.1+1.2 产物判断；不要臆造技术或功能
2 content.json 必须一一覆盖大纲里的每个章节 id/title
3 list 模式的 items[] 为顺序项（render.as=numbered），不是新标题；导出用编号段落
4 图/表编号按模板 figureLabelTemplate/tableLabelTemplate 的“章-序”生成
5 不生成正文，只生成写作计划（plan）、提示词（textPrompt/figurePlan/tablePlan）与 figures/tables 的占位（或直接引用 1.1/1.2 产物）
6 若发现缺失文件（某表无 JSON 或 SVG），对应项标记 status=failed，并在报告中提示；流程不阻断

—— 模块提示词（按章节类型/关键词匹配） ——

[模块：相关技术介绍（占位符替换）]
任务：
1 定位标题含“相关技术介绍/技术介绍”等的章节及其子项（可能包含 {{jishu1}}/{{jishu2}}/{{jishu3}}）
2 基于 ./source/ 与 ./CLAUDE.md 的证据，识别 3 项最具代表性的技术（后端框架/数据访问/缓存/认证/数据库/前端等维度优先）
3 生成 3–4 个候选并自动采纳最佳项，替换占位符文本；写回 outline.json
4 在 content.json 对应章节设置 plan.wantText=true，生成 textPrompt
输出（需在报告中列明）：每个占位符的候选、采纳理由与证据文件（路径+关键词或行号范围）

[模块：系统用例图（列表型 + 图）]
判定条件：标题包含“用例图/Use Case”
任务：
1 设置章节为 list 模式（itemType=actorUseCase）
2 基于源码/文档识别系统角色（≤5）；为每个角色生成一个 item：
   - order 连续编号；title=“<角色>角色”；render.as=numbered
   - plan.wantText=true；plan.wantFigure=true
   - figurePlan[0]: figureTitle=“<角色>用例图”；figureFocus=“UML 用例图，强调参与者、用例、关系（extend/include）、系统边界”
   - textPrompt：描述该角色目标、关键用例、边界与约束
3 章节本身可写一段总述（textPrompt），无强制图/表
4 不当标题，只渲染为编号段落

[模块：数据库设计（列表型 + 表 + 图｜复用 1.1/1.2，并自动生成总体ER图）]
判定条件：标题包含“数据库设计/数据库概念设计/数据库逻辑设计/ER”
任务：
1 设置章节为 list 模式（itemType=entity）
2 遍历 ./paper/exports/tables/ 下全部 Tab-*.json，为每个表生成一个 item（一个不漏）：
   - order 连续编号
   - 解析 JSON 的 tableName 与 tableCnName，title = “<tableName> 实体（<tableCnName>）”
   - render.as=numbered
   - plan.wantText=true；plan.wantFigure=true；plan.wantTable=true
   - textPrompt：描述该实体的业务定位、关键字段、约束、与其他实体关系（可引用 columns 中的中文列名）
   - tables[0]（直接引用 1.1 产物）：
       {
         "id": "Tab-<tableName>",
         "label": "表{{chapter}}-{{index}} <tableCnName>字段三线表",
         "type": "table",
         "dataPath": "./paper/exports/tables/Tab-<tableName>.json",
         "status": "ready",
         "meta": { "source": "step-1.1" }
       }
   - figures[0]（直接引用 1.2 产物）：
       {
         "id": "Fig-<tableName>",
         "label": "图{{chapter}}-{{index}} <tableCnName>实体局部结构图",
         "type": "uml",
         "imagePath": "./paper/exports/tables/Tab-<tableName>.svg",
         "status": "ready",
         "meta": { "source": "step-1.2" }
       }
   - 若某表缺少 JSON 或 SVG：仍创建 item，但将相应 tables[0] 或 figures[0] 的 status 置为 "failed"，并在报告列出缺失清单
3 章节级别增加一张“数据库总体 ER 图”
   - 目标文件（统一放 tables 目录）：
     - UML 源码：./paper/exports/tables/ER-overview.puml
     - 图片：   ./paper/exports/tables/ER-overview.svg
   - 若 ./paper/exports/tables/ER-overview.svg 已存在：直接引用并在 section.figures 增加：
       {
         "id": "Fig-ER-Overview",
         "label": "图{{chapter}}-{{index}} 数据库总体ER图",
         "type": "uml",
         "umlCodePath": "./paper/exports/tables/ER-overview.puml",
         "imagePath": "./paper/exports/tables/ER-overview.svg",
         "status": "ready",
         "meta": { "source": "step-1.2-or-auto" }
       }
   - 若不存在：自动生成
     a) 读取全部 Tab-*.json，收集实体（tableName, tableCnName）与列（含 PK/FK 线索：约束含 PK/FK；或 *_id 命名；识别中间表如 user_role/order_item 推断多对多）
     b) 以 PlantUML ER 语法组装总体图（实体框显示英文名（中文名）；只列 PK 与关键 FK 以控制密度；关系使用 crow’s foot：||--o{ 等）
     c) 将文本写入 ER-overview.puml
     d) 调用：
        luban-uml render \
          --in "./paper/exports/tables/ER-overview.puml" \
          --out "./paper/exports/tables/ER-overview.svg" \
          --format svg
     e) 渲染成功则按上面的节级 figure 结构写回，status="ready"；失败则 status="failed" 并记录原因

[模块：系统功能详细设计 / 系统功能实现 / 系统功能测试（联动 ≤5）]
判定条件：标题包含“系统功能详细设计 / 系统功能实现 / 系统功能测试”
任务：
1 若“系统功能详细设计”存在：从源码/文档识别系统核心功能模块（≤5）
2 分别在以上三个章节下，按相同功能顺序生成对子项（或单节子标题内容）：
   - 详细设计： 《<功能名>的详细设计》
   - 实现： 《<功能名>的实现》
   - 测试： 《<功能名>功能测试》（测试章节可默认 wantTable=true，tablePlan=测试用例表）
3 若仅存在其中一类章节（如只有“实现”），仍基于源码推断功能模块并生成对应内容
4 保证三类章节的功能顺序完全一致

[模块：软件逻辑架构 / 功能框图（单节 + 图）]
判定条件：标题包含“软件逻辑架构/架构/框图/功能框图”
任务：
1 单节模式；plan.wantText=true；plan.wantFigure=true
2 figurePlan：figureTitle=“系统架构/功能图”；figureFocus=“分层结构、依赖关系、接口边界或模块调用关系”

[模块：功能测试/性能测试（单节 + 表/图）]
判定条件：标题包含“系统功能测试/功能测试/系统性能测试/性能测试”
任务：
1 功能测试：单节；plan.wantText=true；plan.wantTable=true；tablePlan=测试用例表（['用例ID','测试点','输入','预期输出','结果']）
2 性能测试：单节；plan.wantText=true；plan.wantTable=true；tablePlan=性能指标表（['指标项','测试条件','数值/范围','结果']）

输出
A) 机器可读 JSON（stdout 单行）：
{
  "status": "success",
  "project": "<projectName>",
  "outlinePath": "./paper/outline.json",
  "contentPath": "./paper/content.json",
  "sectionCount": <int>,
  "withFigures": ["..."],
  "withTables": ["..."],
  "listSections": [{"id":"<secId>","itemType":"actorUseCase|entity|custom","itemCount":<int>}],
  "placeholdersResolved": {"jishu1":"...","jishu2":"...","jishu3":"...","functionname":"...","funname":"..."},
  "dbDesign": {
    "tablesJsonFound": <int>,
    "tablesSvgFound": <int>,
    "itemsLinked": <int>,
    "overview": "ready|generated|failed",
    "tablesDir": "./paper/exports/tables/"
  }
}

B) 人类可读检查报告：
1 覆盖统计：章节总数、list 节点与 item 个数
2 模块化判定：哪些章节被识别为“用例图/数据库/架构/测试”等
3 数据库设计覆盖：
   - 发现的三线表 JSON 数量（Tab-*.json 清单）
   - 发现的 SVG 数量（Tab-*.svg 清单）
   - 为多少个实体生成了 item 并成功链接 JSON + SVG
   - 总体 ER 图：沿用现有/自动生成/失败及原因
4 占位符替换：列出候选、采纳项与证据来源（文件路径与关键词/行号）
5 文件写入确认：./paper/content.json 与（若有替换）./paper/outline.json
6 失败清单：缺 JSON、缺 SVG、ER 图生成失败等

容错
- 若缺少三线表 JSON 或 SVG，仍生成对应 item，占位 status=failed，并在报告中列出
- 若总体 ER 图生成失败，status=failed；后续可单独重试生成 ER-overview
- 其他非关键失败不阻断流程