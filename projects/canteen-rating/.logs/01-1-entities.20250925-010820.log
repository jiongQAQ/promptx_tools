run-workflow.sh: line 91: 【流程 1.1｜实体类 → 三线表 JSON（含表中文名与字段中文名）】

目标
1 扫描 ./source/ 目录，自动识别所有“实体类/数据模型”文件：
   - Java：@Entity/@Table 等注解的类，或 entity/pojo 目录下的类
   - Python：Django/SQLAlchemy 模型类
   - Node.js：Sequelize/Mongoose schema
   - Go：gorm.Model 或带结构体标签的定义
   - SQL：已有 CREATE TABLE 语句
   - 其他语言：凡定义了数据表/实体的数据结构文件
2 提取每个实体的完整字段信息（字段名、类型、约束/可空、说明），并为**表**与**字段**补充**中文显示名**：
   - 表中文名（tableCnName）
   - 字段中文名（逐字段）
3 为每个实体生成一个 **三线表 JSON** 文件（仅 JSON，不输出 SQL），用于后续渲染。

输入
- ./source/ 源码目录
- （可选）./CLAUDE.md：若包含数据字典或命名规范，优先按其中规则命名中文名

输出
1 三线表 JSON 文件（每个实体一份）
   - 存放路径：./paper/exports/tables/
   - 文件命名：Tab-<tableName>.json  （tableName 一律小写 + 下划线）
   - 内容结构（在原有四列基础上新增“字段中文名”列，并增加表中文名）：
     {
       "tableName": "users",
       "tableCnName": "用户表",
       "columns": [
         ["字段名", "字段中文名", "类型", "约束", "说明"],
         ["id", "编号", "BIGINT", "PK, NOT NULL", "主键"],
         ["username", "用户名", "VARCHAR(50)", "NOT NULL", "登录账号"],
         ["password", "密码", "VARCHAR(255)", "NOT NULL", "加密存储"],
         ["created_time", "创建时间", "DATETIME", "", "记录生成时间"]
       ]
     }

2 机器可读 JSON 摘要（stdout 单行）
   {
     "status": "success",
     "project": "<projectName>",
     "entityCount": <int>,
     "tableJsonDir": "./paper/exports/tables/",
     "tables": [
       {"name":"users","cn":"用户表","columns":5},
       {"name":"orders","cn":"订单表","columns":8}
     ],
     "failList": [
       {"file":"Payment.java","field":"totalAmount","reason":"类型未识别"}
     ]
   }

3 人类可读检查报告
   - 实体总数与列表（表英文名 → 表中文名）
   - 每表字段数、示例前几行
   - 已生成 JSON 文件列表（相对路径）
   - 未识别字段/类型（若有）
   - 中文名来源与覆盖规则说明（见下）
   - 确认所有三线表 JSON 已写入
   - 下一步建议（进入流程 3 正文/图表生成）

中文名识别与生成规则（从强到弱的证据优先级）
1 明确证据（最高优先）：
   - 代码注解/标签/元数据上的中文：如 JPA @Column(comment="用户名")、Django verbose_name、Sequelize/Mongoose 的 comment/label、Go struct tag `comment:"用户ID"`
   - SQL COMMENT 或 /* 中文说明 */、-- 中文注释
   - ./CLAUDE.md 或 docs 中的字段/表中英文对照表
2 结构化线索：
   - 文件/类/集合名中的中文片段（若存在）
   - 领域词典（如 user→用户、order→订单、payment→支付、created_at→创建时间、updated_at→更新时间、is_xxx→是否XXX 等）
3 形态学与模式映射（无显式证据时）：
   - 蛇形/驼峰分词 → 基础词典映射 + 常见后缀翻译
     - id→编号、code→编码、name→名称、title→标题、desc/description→描述、remark→备注、status→状态
     - type→类型、count→数量、total/amount→金额、price→价格、rate→比率、level→等级
     - time/at/date→时间/日期、created/created_at→创建时间、updated/updated_at→更新时间
     - is_/has_ 前缀→“是否…”
   - 缺乏可靠线索时，用合理中文化名并在报告中标注“自动推断”
4 覆盖策略：
   - 若多处证据冲突，按优先级 1 > 2 > 3 采纳；./CLAUDE.md 的明确表述优先级与 1 同级
   - 采纳结果要在报告中给出“来源说明”（文件/注解/规则）

字段类型与约束映射
- 语言 → 通用 SQL 样式类型映射仅用于三线表的“类型”展示（不产 SQL）：
  - Java: String→VARCHAR(255)，int/Integer→INT，long/Long→BIGINT，LocalDate/LocalDateTime/Date→DATE/DATETIME，boolean→TINYINT(1)
  - Python: CharField(n)→VARCHAR(n)，Text→TEXT，Integer→INT，Float/Decimal→DECIMAL(10,2)，DateTime→DATETIME，Boolean→TINYINT(1)
  - JS/TS: STRING(n)→VARCHAR(n)，INTEGER→INT，BIGINT→BIGINT，DATE→DATETIME，BOOLEAN→TINYINT(1)
  - Go: string→VARCHAR(255)，int→INT，int64→BIGINT，time.Time→DATETIME
- 约束拼接：
  - 主键：PK；非空：NOT NULL；唯一：UNIQUE；自增：AUTO_INCREMENT；默认值：DEFAULT <val>
  - 未识别时留空或标记 UNKNOWN，并在 failList 中记录

命名与输出规范
- 表名与字段名：统一小写 + 下划线；不改源码中的真实命名，仅用于输出规范（必要时保留原名于说明列）
- 文件目录：./paper/exports/tables/  （若不存在需创建）
- 仅生成 JSON 文件，不覆盖其它输出

容错
- 必须覆盖所有实体；若某实体解析失败，在报告中记录并继续处理其他实体
- 字段无法识别类型 → 用 UNKNOWN 并进入 failList
- 若未识别到任何实体，应报告“未发现可解析的实体定义”，并退出: File name too long
