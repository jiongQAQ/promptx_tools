{
  "id": "5.1.2",
  "title": "实现过程",
  "text": "用户认证模块的实现基于Spring Security和JWT。首先配置SecurityFilterChain，定义URL权限规则，放行登录注册接口，其他接口需要认证。实现UserDetailsService接口的loadUserByUsername方法，从数据库加载用户信息并转换为UserDetails对象。配置JwtAuthenticationFilter，在doFilterInternal方法中解析请求头的Token，验证有效性并设置Authentication到SecurityContext。实现AuthController，提供/api/auth/register和/api/auth/login接口，登录成功后调用JwtTokenUtil生成Token返回。前端使用Axios拦截器在请求头中自动添加Authorization: Bearer <token>。权限控制使用@PreAuthorize('hasRole(\"ADMIN\")')注解标注需要管理员权限的方法。实现效果如图所示，展示了登录界面和认证成功后的主界面。",
  "word_limit": 300,
  "imagePath": "${impl}/impl-auth.png",
  "content": "用户认证模块的实现基于Spring Security安全框架和JWT令牌技术，通过合理的配置和自定义组件的开发，实现了完整的认证和授权功能。\n\n首先，在Spring Security配置类中定义SecurityFilterChain，配置系统的安全策略。使用http.authorizeHttpRequests()方法定义URL的访问权限规则：放行登录和注册接口（/api/auth/register、/api/auth/login），允许匿名访问；放行Swagger文档接口，便于API调试；其他所有接口都需要经过身份认证才能访问。配置CORS跨域支持，允许前端跨域请求后端API。禁用CSRF防护，因为使用JWT令牌认证，不依赖Cookie，不存在CSRF风险。配置Session管理策略为STATELESS无状态模式，服务器不创建和维护Session，符合前后端分离的架构特点。\n\n其次，实现UserDetailsService接口的自定义类CustomUserDetailsService，重写loadUserByUsername方法。该方法在用户登录时被Spring Security调用，根据用户名从数据库查询用户信息。通过UserMapper查询用户记录，如果用户不存在则抛出UsernameNotFoundException异常。查询到用户后，将用户信息转换为Spring Security要求的UserDetails对象，包括用户名、加密后的密码、角色权限列表、账户是否锁定、账户是否过期等状态信息。角色信息转换为GrantedAuthority集合，角色名称需要加上\"ROLE_\"前缀（如\"ROLE_ADMIN\"），这是Spring Security的约定。\n\n第三，配置自定义的JWT认证过滤器JwtAuthenticationFilter，继承OncePerRequestFilter确保每个请求只执行一次。在doFilterInternal方法中，从请求头的Authorization字段提取Token，去掉\"Bearer \"前缀得到纯Token字符串。调用JwtTokenUtil工具类的validateToken方法验证Token的签名和有效期，验证通过后调用getUsernameFromToken方法从Token中解析出用户名。根据用户名加载用户信息，构造UsernamePasswordAuthenticationToken对象，设置用户信息和权限，将Authentication对象设置到SecurityContextHolder的上下文中，这样后续的请求处理过程就可以获取当前登录用户信息。如果Token验证失败，不设置Authentication，请求会因为未认证被拒绝。\n\n第四，实现AuthController控制器，提供用户认证相关的REST接口。实现POST /api/auth/register接口处理用户注册，接收RegisterDTO对象，调用UserService的register方法完成注册逻辑。实现POST /api/auth/login接口处理用户登录，接收LoginDTO对象（包含用户名和密码），调用AuthenticationManager的authenticate方法进行认证，认证成功后调用JwtTokenUtil的generateToken方法生成JWT令牌，将令牌封装在Result对象中返回给前端。实现GET /api/auth/info接口获取当前登录用户信息，从SecurityContextHolder中获取用户信息并返回。\n\n前端实现方面，使用Axios库发送HTTP请求。配置Axios请求拦截器，在每个请求发送前，从localStorage中读取保存的Token，设置到请求头的Authorization字段。配置Axios响应拦截器，捕获401未授权错误，自动跳转到登录页面并清除本地存储的Token，提示用户重新登录。在登录页面组件中，用户填写表单后，调用登录API，登录成功后将返回的Token保存到localStorage，跳转到系统主页面。\n\n权限控制的实现使用Spring Security的方法级安全注解。在需要特定角色才能访问的Controller方法上，添加@PreAuthorize注解，如@PreAuthorize(\"hasRole('ADMIN')\")表示只有管理员角色可以访问该方法。Spring Security的AOP机制会在方法执行前进行权限检查，如果当前用户不具备所需角色，抛出AccessDeniedException异常，全局异常处理器捕获该异常并返回403禁止访问错误给前端。前端根据用户角色动态显示菜单和按钮，隐藏用户无权访问的功能入口，提升用户体验。\n\n模块实现效果如图所示，展示了用户登录界面、登录成功后的系统主界面，以及权限控制的实际效果。登录界面提供用户名和密码输入框，点击登录按钮后进行身份验证，验证成功后跳转到主界面并显示欢迎信息。不同角色的用户登录后看到的菜单和功能不同，体现了基于角色的权限控制效果。",
  "sourceFile": "chapter.5.1.2.json",
  "extractedAt": "2025-09-30T10:25:51.843Z"
}